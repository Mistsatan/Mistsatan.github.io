<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[“将程序锁定到任务栏”选项 与 删除桌面快捷方式箭头]]></title>
    <url>%2F2018%2F08%2F22%2FPin-to-Taskbar-and-Remove-Shortcut-Arrow.html</url>
    <content type="text"><![CDATA[昨天误将chrome从任务栏解锁之后，竟然发现右键不再出现“将此程序锁定到任务栏”的选项，思来想去觉得可能和前几天删除了桌面快捷方式箭头有关，在网上搜索之后发现果然如此，在此进行整理。 网上教程一搜一大把，仍然先放上参考链接： win7右键点击IE图标没有“将此程序锁定到任务栏’选项如何找回 如何去掉桌面图标的快捷箭头 在Win7下去掉快捷方式箭头的简便手动操作 重新添加“将程序锁定到任务栏”选项方法一 用win+R键调出运行窗口 依次输入以下三条命令： 123cmd /k reg add &quot;HKEY_CLASSES_ROOT\lnkfile&quot; /v IsShortcut /fcmd /k reg add &quot;HKEY_CLASSES_ROOT\piffile&quot; /v IsShortcut /fcmd /k taskkill /f /im explorer.exe &amp; explorer.exe 或者直接输入以下命令： 1cmd /k reg add &quot;HKEY_CLASSES_ROOT\lnkfile&quot; /v IsShortcut /f &amp; reg add &quot;HKEY_CLASSES_ROOT\piffile&quot; /v IsShortcut /f &amp; taskkill /f /im explorer.exe &amp; explorer.exe 方法二 新建一个文本文档，文档中输入以下内容： 123reg add &quot;HKEY_CLASSES_ROOT\lnkfile&quot; /v IsShortcut /freg add &quot;HKEY_CLASSES_ROOT\piffile&quot; /v IsShortcut /ftaskkill /f /im explorer.exe &amp; explorer.exe 将文档扩展名改为.bat，然后双击运行 按照上述方法设置之后，在任务栏程序上点击右键就会显示“将此程序锁定到任务栏”选项了。不过，此时会发现，已经被删除的桌面快捷方式箭头又会重新出现，因此也附上删除桌面快捷方式箭头的方法。 删除桌面快捷方式箭头方法一 用win+R键调出运行窗口 直接输入以下命令： 1cmd /k reg delete &quot;HKEY_CLASSES_ROOT\lnkfile&quot; /v IsShortcut /f &amp; taskkill /f /im explorer.exe &amp; start explorer.exe 或者依次输入以下命令： 123cmd /k reg delete &quot;HKEY_CLASSES_ROOT\lnkfile&quot; /v IsShortcut /fcmd /k reg delete &quot;HKEY_CLASSES_ROOT\piffile&quot; /v IsShortcut /f [该命令可选]cmd /k taskkill /f /im explorer.exe &amp; explorer.exe 方法二 新建一个文本文档，文档中输入以下内容： 123reg delete &quot;HKEY_CLASSES_ROOT\lnkfile&quot; /v IsShortcut /freg delete &quot;HKEY_CLASSES_ROOT\piffile&quot; /v IsShortcut /ftaskkill /f /im explorer.exe &amp; explorer.exe 将文档扩展名改为.bat，然后双击运行 然而，按照上述方法设置之后，桌面快捷方式的箭头被删掉了，可是“将此程序锁定到任务栏”选项又会消失不见。 两种功能不能同时生效能够看到，修改注册表lnkfile和piffile的IsShortcut键这种方法，只能实现一个功能而必须舍弃另一个功能，这在实际使用中真的是十分不便。 同时，还有一个副作用，删除桌面快捷方式箭头的同时，“另存为”资源管理器中的“桌面”快捷选择项也会不见，如图：为了解决问题，再次搜索，果然发现了二者可以同时生效的方法。 解决方法这种方法的主要思想是：并不是真正意义上去掉箭头，而只是使用Win7自带的图标库中的透明图标代替快捷方式的箭头，这样就实现了隐藏箭头的效果，很方便很快捷。 首先需要了解以下内容： 1. Window图标库Windows 系统自己的默认图标（回收站、计算机、控制面板等等）都保存在系统盘（一般是C盘）的Windows/System32 文件夹里面的一些DLL文件里面——imageres.dll、shell32.dll 和 moricons.dll 等几个系统文件。 moricons.dll：XP以前老风格图标； shell32.dll：XP常用图标； imageres.dll：Vista和Win7风格的图标。 其中，imageres.dll的196号、shell32.dll的50~53号（其他图标资源编号对照表，详见此处），都是透明图标。 2. Shell Icons 注册表[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer]中，”Shell Icons”子项的29表项，代表的就是快捷方式箭头：129 SI_SHORTCUT Shortcut overlay (small arrow) 关于Shell Icons的其他各个表项值介绍，详见此处。 方法一该方法使用了注册表方式，利用shell32.dll的50号透明图标进行修改。 新建一个文本文档，文档中输入以下内容： 12345678[HKEY_CLASSES_ROOT\lnkfile]&quot;IsShortcut&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\piffile]&quot;IsShortcut&quot;=&quot;&quot;[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons]&quot;29&quot;=&quot;C:\\\\Windows\\\\System32\\\\shell32.dll,50&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons]&quot;29&quot;=&quot;C:\\\\Windows\\\\System32\\\\shell32.dll,50&quot; 将文档扩展名改为.reg，然后双击运行写入注册表 运行以下命令重启资源管理器，或者注销一次，则会生效1taskkill /f /im explorer.exe &amp; explorer.exe 方法二该方法的原作者巧妙使用了imageres.dll的196号透明图标。 去掉快捷方式箭头的批处理文件 DeleteArrow.bat（代码解释可见原博文） 123456reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons&quot; /v 29 /d &quot;%systemroot%\system32\imageres.dll,196&quot; /t reg_sz /ftaskkill /f /im explorer.exeattrib -s -r -h &quot;%userprofile%\AppData\Local\iconcache.db&quot;del &quot;%userprofile%\AppData\Local\iconcache.db&quot; /f /qstart explorerpause 恢复快捷方式箭头的批处理文件 RecoverArrow.bat 123456reg delete &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons&quot; /v 29 /ftaskkill /f /im explorer.exeattrib -s -r -h &quot;%userprofile%\AppData\Local\iconcache.db&quot;del &quot;%userprofile%\AppData\Local\iconcache.db&quot; /f /qstart explorerpause 至此，大功告成。]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>电脑技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客-NexT主题优化记录]]></title>
    <url>%2F2018%2F08%2F22%2FHexo-Blog-Theme-NexT-Optimization-Records.html</url>
    <content type="text"><![CDATA[本文主要用于记录部署在Github上的Hexo博客-NexT主题优化过程中的一些操作，内容大多来自网上各博客，大佬们都写得很全面了，文中仅做搜集整理工作，以便之后查阅。 0. Hexo博客搭建搭建步骤这部分主要参考这篇文章，步骤完整，表达准确，无赘述，专心跟着走可以绕过一些坑（别问我怎么知道），棒棒哒： 动手在GitHub上搭建Hexo博客 一些Hexo基本命令 功能 命令 说明 新建文章 hexo new [layout] &lt;filename&gt;，简写hexo n &lt;filename&gt; -没有设置layout时候，默认使用 _config.yml 中的 default_layout参数代替-如果标题包含空格，需要用引号括起来 新建草稿 hexo n draft &lt;filename&gt; 预览草稿 -修改配置文件_config.yml中的配置项：render_drafts: true-启动命令：hexo s –drafts 发表草稿 hexo publish [layout] &lt;filename&gt; 生成静态文件 hexo generate，简写 hexo g -d (–deloy)：文件生成后立即部署网站-w (–watch)：文件生成后件监视文件改动 本地启动服务器 hexo sever，简写hexo s，默认4000端口 -p (–port) 8888：重设端口-s (–static)：启用静态文件-l (–log)：启动日记记录，使用覆盖记录格式 部署网站 hexo delpoy，简写hexo g -g (–generate)：部署之前预先生成静态文件 渲染文件 heox render &lt;file1&gt; [file2] -o path path：设置输出路径 从其他博客系统迁移内容 hexo migrate &lt;type&gt; 清除缓存 hexo clean -清除缓存文件 (db.json) 和已生成的静态文件 (public)-如果发现对站点的更改无论如何也不生效，则可能需要运行该命令 列出网站资料 hexo list &lt;type&gt; 显示版本 hexo version . Hexo官网上有说明文档和很多主题，我最初配置的主题是Flexy，很漂亮。然而好奇心驱使，我想自己修改优化一些细节，无奈之前没有接触过，无从入手，检索发现NexT主题使用极其广泛，有丰富的博文可以参考，所以配置了NexT，开始了入坑之行。 1. 主题设定该部分内容大多来自NexT说明文档（部分内容未同步于最新版） 首先区分配置文件： 配置文件 路径 备注 站点配置文件 …/Hexo/_config.yml 官方文档-参数配置 主题配置文件 …/Hexo/themes/next/_config.yml . 设置「界面语言」编辑 站点配置文件， 将 language 设置成所需要的语言，如以下表格所示： 语言 代码 设定示例 备注 English en language: en 默认 简体中文 zh-CN language: zh-CN 繁體中文 zh-HK 或 zh-TW language: zh-HK . 选择「Scheme」目前 NexT 支持四种 Scheme，默认为Muse。Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字，会看到有四行 scheme 的配置：1234scheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 将想选择的 scheme 前面注释 # 去除即可。 设置「菜单」123456789menu: home: / || home # 主页 tags: /tags/ || tags # 标签 categories: /categories/ || th # 分类 archives: /archives/ || archive # 归档 about: /about/ || user # 关于我 #schedule: /schedule/ || calendar # 安排 #sitemap: /sitemap.xml || sitemap # 站点地图 #commonweal: /404/ || heartbeat # 404公益 可以直接将已有的菜单项前面注释 # 去除，也可以自己添加，添加的新项名称可以在 …/themes/next/languages 下的语言文件（如zh-CN.yml）中进行相应的编辑。“||”之后的字段是菜单项的图标名，NexT 使用的图标由 Font Awesome 提供，可以通过修改menu_icons字段的enable为true或者false来指定是否开启菜单图标。12menu_icons: enable: true 待续。。。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next主题优化</tag>
        <tag>待续</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fseek()和ftell()函数]]></title>
    <url>%2F2018%2F08%2F09%2Ffunction-fseek-and-ftell.html</url>
    <content type="text"><![CDATA[在做CTF的逆向题目时遇到的函数，简单记录一下。 首先放上参考链接： https://blog.csdn.net/libing403/article/details/73158972 https://www.cnblogs.com/xingyunblog/p/3675568.html fseek()1int fseek(FILE *stream, long offset, int whence); 功能：用来移动文件流的读写位置. 参数说明： stream：已打开的文件指针 offset：偏移量（long类型），表示要从起始点开始要移动的距离： 模式 对应数值 正数 向前移 负数 向后移 0 保持不动 whence：模式，用于确定起始位置： 模式 对应数值 偏移量的起始位置 SEEK_SET 0 文件开头 SEEK_CUT 1 文件当前位置 SEEK_END 2 文件末尾 举例：123456//fp是一个文件指针fseek(fp, 0L, SEEK_SET); //定位至文件开始处fseek(fp, 10L, SEEK_SET); //定位至文件中的第10个字节fseek(fp, 2L， SEEK_CUR); //从文件当前位置前移2个字节fseek(fp, 0L, SEEK_END); //定位至文件结尾fseek(fp, -10, SEEK_END); //从文件结尾处回退10个字节 返回值： 一切正常，则返回0 出现错误（例如试图移动的距离超出了文件的范围），则返回-1 ftell()1long ftell(FILE * stream); 功能：用来获取文件读写指针的当前位置 参数说明： stream：已打开的文件指针 返回值： 成功，则返回当前的读写位置 失败，则返回 -1]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018巅峰极客writeup（Misc）]]></title>
    <url>%2F2018%2F08%2F03%2F2018-Peakgeek-Writeup-Misc.html</url>
    <content type="text"><![CDATA[作为一个渣渣，带着去看各路神仙打架的想法报名了这次的“巅峰极客”CTF比赛，7.21第一场线上赛果然从头水到尾。。。为了方便之后巩固，把近几天学习大佬们的writeup过程中总结整理的内容记录下来，第一次写成博客。 我只是个搬运工，以下是众大佬们的writeup： 白帽100 双螺旋 无糖 还有一个 最后一个 1. warmup - 100pt首先拿到一张图片warmup.bmp，用Stegsolve打开： 1java -jar Stegsolve.jar 经大佬们发现，RGB三个通道的LSB都是明显有数据在的（我眼瞎，当时翻来覆去好几遍真没看出来）：分别查看各个通道的LSB，发现了存放的数据是用Ook!和brainfuck加密的：分别将三块数据保存出来，用这个网站在线解密，得到以下三部分内容，拼起来就是flag： flag{db640436- 7839-4050-8339 -75a972fc553c flag{db640436-7839-4050-8339-75a972fc553c} 2. loli - 150pt拿到一张图片1.png，看起来像二维码，用工具扫描，得到一个提示255：根据另一个提示0xFF，将1.png放到WinHex中，0xFF异或整个文件，在得到的文件末尾看到字符串“black and white”：用binwalk查看得到的文件，发现其中包含了一个图片：根据隐藏图片的偏移，用WinHex将图片提取出来，能够看到，图片中，按照行来看，以8个像素点（黑/白）为一组，每一组之间用白点来分隔，根据前面“black and white”提示，不难联想到应该是二进制流转换成字符：参考各大佬的writeup，写出脚本如下：1234567891011121314151617181920212223242526272829303132from PIL import Imagedef getBinaryToChar(): count = 0 ans = "" binStr = "" # 转换成灰度图像（黑点0，白点255） img = Image.open('./noname.png').convert('L') # 遍历像素点（按行读） width, height = img.size for h in range(height - 1): # 是否-1均可，最后一行是11个0111111111 for w in range(width - 1): # 需要-1，最后一列全是0 pixel = img.getpixel((w, h)) if pixel == 0: color = 1 # 黑点置1 else: color = 0 # 白点置0 # 9个点一组，构成0xxxxxxxx count += 1 ans += str(color) if count == 9: if ans != "011111111": binStr += chr(int(ans,2)) count = 0 ans = "" return binStrif __name__ == '__main__': strr = getBinaryToChar() print strr with open('res.txt', 'wb') as f: f.write(strr) 打开得到的res.txt，看到flag：flag{e0754197-e3ab-4d0d-b98f-96174c378a34} 3. flows - 200pt拿到一个pcap包，用wireshark打开，发现是USB协议。按照协议排序，一个个点击查看包内容，发现有个包（95）里面疑似有tips：将数据另存到txt中，打开可以看到两个提示：继续查看包，发现两个长度比较大的包很可疑（55和74）：分别将数据另存出来，用010打开，看到这两个文件头都是D4C3B2A1，就是pcap文件：修改后缀为.pcap，用wireshark打开，有效数据存放在leftover capture data这里：用wireshark自带的tshark把leftover capture data的内容提取出来：【tshark命令行详细参见这里】12tshark -r pack55.pcap -T fields -e usb.capdata &gt; pack55.txttshark -r pack74.pcap -T fields -e usb.capdata &gt; pack74.txt 接下来就需要从txt文件中过滤出键盘击键和鼠标相关的流量：【这里主要参考这位大佬的博客以及这个博客】 键盘数据包的数据长度为8个字节。每次key stroke都会产生一个keyboard event usb packet（所以第一个tips所说第一个字节为02表示按下了Left Shift键） Byte1 |--bit0: Left Control是否按下，按下为1 |--bit1: Left Shift 是否按下，按下为1 |--bit2: Left Alt 是否按下，按下为1 |--bit3: Left GUI 是否按下，按下为1 |--bit4: Right Control是否按下，按下为1 |--bit5: Right Shift 是否按下，按下为1 |--bit6: Right Alt 是否按下，按下为1 |--bit7: Right GUI 是否按下，按下为1 Byte2 暂不清楚，有的地方说是保留位Byte3-Byte8 这六个为普通按键，击键信息集中在第3个字节 鼠标数据包的数据长度为4个字节。鼠标移动时表现为连续性，与键盘击键的离散性不一样，不过实际上鼠标动作所产生的数据包也是离散的 Byte1 代表按键，当取0x00时，代表没有按键、为0x01时，代表按左键，为0x02时，代表当前按键为右键Byte2 可以看成是一个signed byte类型，其最高位为符号位，当这个值为正时，代表鼠标水平右移多少像素，为负时，代表水平左移多少像素Byte3 与第二字节类似，代表垂直上下移动的偏移 第一个包pack55.txt为键盘数据包，需要按照对应关系将键盘按键输出出来，根据第一个tips，注意第一个字节为02表示按了shift键，在大佬的脚本基础上稍作修改，脚本如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546mappings = &#123; 0x04:"a", 0x05:"b", 0x06:"c", 0x07:"d", 0x08:"e", 0x09:"f", 0x0A:"g", 0x0B:"h", 0x0C:"i", 0x0D:"j", 0x0E:"k", 0x0F:"l", 0x10:"m", 0x11:"n", 0x12:"o", 0x13:"p", 0x14:"q", 0x15:"r", 0x16:"s", 0x17:"t", 0x18:"u", 0x19:"v", 0x1A:"w", 0x1B:"x", 0x1C:"y", 0x1D:"z", 0x1E:"1", 0x1F:"2", 0x20:"3", 0x21:"4", 0x22:"5", 0x23:"6", 0x24:"7", 0x25:"8", 0x26:"9", 0x27:"0", 0x28:"\n",0x29:"[ESC]", 0x2A:"\b", 0X2B:"\t", 0x2C:" ", 0x2D:"-", 0x2E:"=", 0x2F:"[", 0x30:"]", 0x31:"\\",0x32:"`", 0x33:";", 0x34:"'", 0x36:",", 0x37:".", 0x38:"/" &#125;mappings_shift = &#123; 0x04:"A", 0x05:"B", 0x06:"C", 0x07:"D", 0x08:"E", 0x09:"F", 0x0A:"G", 0x0B:"H", 0x0C:"I", 0x0D:"J", 0x0E:"K", 0x0F:"L", 0x10:"M", 0x11:"N", 0x12:"O", 0x13:"P", 0x14:"Q", 0x15:"R", 0x16:"S", 0x17:"T", 0x18:"U", 0x19:"V", 0x1A:"W", 0x1B:"X", 0x1C:"Y", 0x1D:"Z", 0x1E:"!", 0x1F:"@", 0x20:"#", 0x21:"$", 0x22:"%", 0x23:"^", 0x24:"&amp;", 0x25:"*", 0x26:"(", 0x27:")", 0x28:"\r",0x29:"[ESC]", 0x2A:"\b", 0X2B:"\t", 0x2C:" ", 0x2D:"_", 0x2E:"+", 0x2F:"&#123;", 0x30:"&#125;", 0x31:"|", 0x32:"~", 0x33:":", 0x34:"\"",0x36:"&lt;", 0x37:"&gt;", 0x38:"?" &#125;def keyboard_extract(): output = "" keys = open('pack55.txt') for line in keys: if len(line)!= 24: continue list = line.split(":") if list[2]=='00': continue num = int(list[2],16) if num in mappings: if list[0] == '02': output += mappings_shift[num] elif list[0] == '00': output += mappings[num] else: output += '[unknown]' keys.close() print outputif __name__ == '__main__': keyboard_extract() 第二个包pack74.txt为鼠标数据包，按照第二个tips，只关注第一个字节，猜测01表示0，02表示1，将其提取出来，脚本如下：1234567891011121314151617181920212223242526272829import redef bin2str(bin): str = '' mo = len(bin)%8 if (mo): bin= '0'*(8-mo) + bin chars = re.findall(r'.&#123;8&#125;',bin) for char in chars: str += chr(int(char, 2)) return strdef mouse_extract(): binstr = "" keys = open('pack74.txt') for line in keys: list = line.split(":") if list[0]=='00': continue elif list[0] == '01': binstr += "0" elif list[0]=='02': binstr += "1" str = bin2str(binstr) keys.close() print strif __name__ == '__main__': mouse_extract() 分别运行以上两个脚本，得到两个字符串，拼起来就是flag了： flag{u5b_key bo4rd_m0use} flag{u5b_keybo4rd_m0use}]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>巅峰极客</tag>
      </tags>
  </entry>
</search>
