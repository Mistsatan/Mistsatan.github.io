<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【2018国庆•港澳广“逛吃逛吃”标准游客地标+网红美食店打卡7日轻度游】流水账？伪游记？全攻略（成都-广州-珠海-澳门-香港）]]></title>
    <url>%2Farticles%2FThe-Trip-to-Guangzhou-Macau-and-Hongkong.html</url>
    <content type="text"><![CDATA[前言从上一次毕业旅行开始，我和两位室友小可爱就都一直心心念念着港澳游，无奈多次计划落空。感慨或许2018国庆将会成为我们学生时代的最后一次国庆长假，不能只是敷衍度过，所以，我们决定随心出发。8月，我们就早早地开始筹备这次旅行。 出发时间 出行天数 人物 人均费用 2018-10-01 7天 朋友，同行3人 约￥3000，HK$900 筹备阶段行程规划的开端，毫无疑问是“机票/火车票+住宿+签证”。 机票/火车票我们首先查机票，很遗憾，尽管提前一个多月，从成都到澳门、香港甚至是广州、深圳的机票就都已经浮在千元以上，不愧是国庆高峰期。而在12306上看到成都到广州的高铁票价￥560左右，但要耗时10h。 对于我们这样的穷学生来说，单单是往返机票就足够在国内任何地方美滋滋地度假一周了，所以无奈，只能选择牺牲时间保护钱包，把广州加入了行程单中。 之后的旅程证明，虽然损失了2天时间在路上，但其余5天中满满的愉悦已然值得。何况有一个小伙伴和我都鲜少乘坐高铁，也算是一次新的体验吧。 住宿不查不知道，一查吓一跳。香港和澳门的酒店价格在国庆期间真的是贵出天际。然而，住宿这一块是再怎么也没有替换方案的，退一步，也只能是选择住民宿、青旅等等，但毕竟是国庆，价格都比平时翻了一两番，而且因为我们是3个人，对床的大小又有着额外的要求…… 所幸，花了九牛二虎之力，我终于预订到了自认为性价比还可以的房间，香港￥660，澳门￥515，每人均摊后也勉强符合我们“穷游”的标准。 【ps】出境预订房间推荐使用APP： 预订酒店Booking、Agoda（可以和携程、去哪儿等APP对比价格，有的房间在不同平台可能会有更低的价格） 预订民宿推荐Arbnb 国内酒店预订我都是用首旅如家APP（直接用官方渠道预订，毫无疑问比第三方便宜，而且很方便取消） 单单是往返火车票和港澳住宿费用，已经让我们预料到，这次旅程就算再省也必定是一次烧钱之旅。但是呢，自己选定的目的地，再贵也只能咬着牙去了。 签证我们此次去港澳需要准备：港澳通行证+赴港签注1次+赴澳签注1次。 港澳通行证之前就已经办好了新版的电子港澳通行证，卡片式，身份证大小，长下面这样。 这种港澳通行证在申办时，除了面部信息采集之外，还录入了指纹。相较于传统的本式通行证，卡片式通行证的优点在于：一、可以用自助签注机申请办理签注，立等可取；二、过关时可以直接走自助通道，排队时间短、过关速度快。在成都申办往来港澳通行证非常方便，可以直接去成都市出入境接待中心办理（位置很好找，就在天府广场毛主席像背后，四川科技馆的斜对面），当然也可以先在出入境网上办事平台上预约。 【ps】预约只能约周一到周五，周六直接去就行，工作时间是上午9：00-下午17:00。 收费情况的话，80元/证，照片采集听说已经免费了，所以，对于成都户口居民，只需要带上身份证和钱去就可以了（之前看到挂靠在学校集体户口下的大学生还需要向学校开具一张户口页，但是实际去办理的时候并没有用到这个）。 办理时效，工作人员会说需要10个工作日，但实际上我和室友分别办理的两次，都只花了2~3个工作日，工作效率杠杠的，但是最好预留足够长的时间提前去办理，以防因为通行证没办理下来耽误了行程。 收到办理完成的短信，就可以带着申办时发给你的取证凭据去领取，如果丢了，需要本人带着身份证去。当然，也可以在申办时选择邮寄方式，这样就能在家坐等通行证了。 签注签注可以在办理港澳通行证的同时申请，这样最为方便。当然，拿着已经办好的港澳通行证去申办签注也十分便捷。还是去成都市出入境接待中心，大厅左侧的自助区有自助签注机，将通行证直接插入之后选择签注类型、次数，接着确认信息、付钱，2分钟就自动办好了签注，so easy。成都市是开通了港澳自由行的，因此可以直接申请个人旅游签注（G签），有的城市没有开通自由行就只能签发团队旅游签注（L签）。 收费情况，一次有效签注15元/件，二次有效签注30元/件。 【ps】一定记得带银行卡，自助签注机付款方式暂时不支持支付宝、微信和现金。 关于签注有两条值得注意的规定： 赴香港可以申请3个月一次签注、3个月二次签注、1年一次签注、1年二次签注，而赴澳门只能申请3个月一次签注、1年一次签注，每次在香港或者澳门逗留不超过7天 根据香港入境事务处规定，内地到香港到澳门到香港到内地的行程顺序，而且在港澳两地停留合计不超过7天的情况下，澳门段被认作附带行程，仅需要香港、澳门签注各一次 按照我的理解，总结一下： 出行顺序 签注 内地-香港-内地-香港-内地 香港签注2次 内地-澳门-内地-澳门-内地 澳门签注2次（不可行） 内地-香港-澳门-香港-内地 香港、澳门签注各1次即可 内地-澳门-香港-澳门-内地 香港签注1次、澳门签注2次（不可行） 其他准备事项电话卡去港澳必备一张电话卡，主要是用于上网。虽然港澳Wifi普及程度非常高，公交车、商场全都有免费Wifi，但是出门在外查地图、发qq、发微信都还是需要数据流量才方便。支付宝上可以直接购买境外流量包，价格也不贵，但是听说体验感很差，所以还是选择买电话卡。淘宝、飞猪上面有很多店卖这种电话里，我们买了港澳通用4日卡，每天500M 4G流量，超额后降为3G不限量。一个人插卡开热点，供另外两人使用，基本没有出现卡顿，唯一的问题就是长时间开热点的手机会更耗电一些、也比较容易发热，但这都不是事儿了。 转换头因为香港和澳门的插座插头是采用英标，和大陆的不同，所以我们在淘宝上购买了一个转换头，准备再额外带插线板过去，这样起码保证三个人的手机、充电宝、pad都能充电。不过实际去了之后发现，我们在澳门住的民宿和在香港住的宾馆都提供了国标的插线板，估计是因为大陆游客还是占大多数吧。虽然没有用到转换头，但是好歹有备无患嘛。 行程规划我们的行程规划是这样的： 简单来说就是：成都-广州-珠海-澳门-珠海-香港-深圳北-广州-成都。 这里做一些解释： 其实10.1可以选择直接从成都到达珠海，这样10.2清早就可以过关去澳门了。但是我们计划当天晚上住在广州，可以去看看著名的“小蛮腰”，第二天去吃早茶，然后在傍晚时分乘坐广珠城铁到达珠海，住在拱北口岸附近，这样10.3就能够早早过关，避开10.2和每天上午的过关高峰期。 10.3玩耍一天后就住在澳门，10.4晚上过关回到珠海，10.5早上从珠海九州港码头坐船去香港，耗时1h。这一段规划是没必要的，其实大可以在10.4下午或晚上直接从澳门坐船去香港，但在香港住比在珠海贵接近一倍，所以单纯是为了省钱，我们就只能选择额外耗时费力一些了。这样规划的弊端就在于，在澳门玩2天，时间绰绰有余，但香港只有2天，时间是非常紧的。不过也有一个小小的好处，我们从澳门回珠海后住同一家酒店，这样就可以把行李箱寄存在珠海，出发去澳门时只用带上必要的生活用品，不用辛苦地拖着笨重的行李箱走在澳门的街头小巷。 10.6晚上我们从香港回广州，第二天从广州出发回成都。这仍然是出于对香港住宿费用高和条件差的双重考虑，我们当天晚上毫无疑问要回到内地；而如果回到深圳，第二天回成都会异常麻烦，因为——没有高铁。正当我在考虑是坐广九直通车还是中港通直通车时，看到了广深港高铁9.23将通车的新闻，这真是个好消息，正好尝尝鲜。 旅程开始10.1 成都-广州10.2 广州10.3 澳门10.4 澳门10.5 香港10.6 香港10.7 广州-成都 未完待续。。。]]></content>
      <categories>
        <category>trip</category>
      </categories>
      <tags>
        <tag>待续</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[是谁占用了我的本地端口？]]></title>
    <url>%2Farticles%2FFind-the-Process-Occupying-a-Local-Port.html</url>
    <content type="text"><![CDATA[用hexo本地预览时，直接输入命令“hexo s”后访问localhost:4000，总是无法显示博客页面。原因是4000端口被其他进程或程序占用，所以只好再加上“-p”参数指定其他端口。今天突然想要看看总是占用4000端口的到底是何方神圣，一下子就搜到了查看方法。 仍然首先放上参考链接： Hexo使用localhost:4000不能进行本地预览 查看某个端口的占用情况——命令：netstat -aon|findstr “XXXX” 打开cmd，输入命令netstat -aon|findstr “4000”： 1234TCP 127.0.0.1:4000 0.0.0.0:0 LISTENING 2252TCP 127.0.0.1:4000 127.0.0.1:49766 ESTABLISHED 2252TCP 127.0.0.1:49766 127.0.0.1:4000 ESTABLISHED 12792UDP 127.0.0.1:40000 *:* 2832 可以看到，是PID为2252的进程占用了4000端口。 查看指定PID对应的进程——命令：tasklist|findstr “XXXX” 继续输入命令tasklist|findstr “2252”： 1FoxitProtect.exe 2252 Services 0 17,008 K 发现PID为2252的进程是“FoxitProtect.exe”，罪归祸首就是它。 结束进程如果有需要，就可以打开任务管理器，结束该进程。或者，继续在cmd中输入命令taskkill /f /t /im FoxitProtect.exe即可。]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>电脑技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Graphviz入门]]></title>
    <url>%2Farticles%2FThe-ABC-of-Graphviz.html</url>
    <content type="text"><![CDATA[Graphviz是一款开源图形可视化软件。用Graphviz来绘图时，只需要编写dot脚本，就能够对图中的节点完成自动布局，非常便捷好用。本文对Graphviz的安装及使用方法进行简单的整理和介绍。 参考： graphviz官网 流程图（Flowchart） graphviz简介 Graphviz初步 Graphviz安装及简单使用 开源项目：【自动】绘图工具 Graphviz——《太子党关系网络》就是用它制作 1. Graphviz简介Graphviz（Graph Visualization）是一款开源图形可视化软件，使用dot作为脚本语言，然后使用布局引擎来解析此脚本，并完成自动布局。 用Graphviz来绘图时，主要工作就是编写dot脚本，说明各个节点之间的关系，而不需要考虑布局；同时，Graphviz也支持定制图中元素的具体特性，例如节点的颜色、字体，表格节点布局，线条样式，超链接和自定义形状等。 Graphviz提供丰富的导出格式，如常用的图片格式、SVG、PDF格式等等。 Graphviz还提供了多种布局模式： 布局 说明 示例 dot 默认布局方式，有向图 neato 无向图 fdp 无向图 sfdp 大型无向图 twopi 径向布局 circo 圆环布局 更多介绍可以查看官方简介。 2. 下载安装Graphviz支持Windows、Linux和Mac OS X等多个平台，本文记录Windows下的安装和简单使用。 Windows版官网下载地址：Graphviz-2.38 安装完成之后，在“开始”菜单-“所有程序”中，能看到Graphviz文件夹里有一个gvedit.exe的快捷方式，如下图，可以将其添加到桌面便于使用。 配置环境变量将Graphviz安装目录下的\bin文件夹添加到Path环境变量中。 安装验证打开cmd，输入命令 dot -version ，如果显示Graphviz版本信息，如下图，说明安装配置成功。 Python环境中安装（Pycharm）打开cmd，输入 pip install graphviz 命令，如下图，则说明安装成功。 3. 简单使用安装完成之后，就可以开始编写dot脚本了。 打开gvedit，新建一个.gv或.dot文件，并输入dot脚本：文件名：test.dot12345678910digraph G &#123; main -&gt; parse -&gt; execute; main -&gt; init; main -&gt; cleanup; execute -&gt; make_string; execute -&gt; printf init -&gt; make_string; main -&gt; printf; execute -&gt; compare;&#125; 有两种方法可以生成相应的图： 命令 gvedit界面 方法一：命令命令格式：1&lt;cmd&gt; &lt;inputfile&gt; -T &lt;format&gt; -o &lt;outputfile&gt; 参数说明： &lt;cmd&gt; dot 渲染的图具有明确方向性 neato 渲染的图缺乏方向性 twopi 渲染的图采用放射性布局 circo 渲染的图采用环型布局 fdp 渲染的图缺乏方向性 sfdp 渲染大型的图，图片缺乏方向性 &lt;format&gt; png、jpg、gif、bmp、tiff、ico、svg等图片格式 pdf、ps/eps等文档格式 完全的输出格式说明见官方文档 该实例可输入以下命令：1dot test.dot -T png -o test.png 方法二：gvedit界面在工具栏Graph-Layout（快捷键F5），或直接点击工具栏最后一个图标（奔跑的小人），即可在窗口中生成预览图。 Graph-Settings（快捷键Shift+F5）可以进行设置，可以选择布局命令（默认dot），也可以选择多种导出的文件类型（默认.png） 该实例生成图如下： 更多实例可见Graphviz Gallery。 dot语言的介绍可见这篇文章，后续将展开相关学习。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Graphviz</tag>
        <tag>dot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“将程序锁定到任务栏”选项 与 删除桌面快捷方式箭头]]></title>
    <url>%2Farticles%2FPin-to-Taskbar-and-Remove-Shortcut-Arrow.html</url>
    <content type="text"><![CDATA[昨天误将chrome从任务栏解锁之后，竟然发现右键不再出现“将此程序锁定到任务栏”的选项，思来想去觉得可能和前几天删除了桌面快捷方式箭头有关，在网上搜索之后发现果然如此，在此进行整理。 网上教程一搜一大把，仍然先放上参考链接： win7右键点击IE图标没有“将此程序锁定到任务栏’选项如何找回 如何去掉桌面图标的快捷箭头 在Win7下去掉快捷方式箭头的简便手动操作 重新添加“将程序锁定到任务栏”选项方法一 用win+R键调出运行窗口 依次输入以下三条命令： 123cmd /k reg add &quot;HKEY_CLASSES_ROOT\lnkfile&quot; /v IsShortcut /fcmd /k reg add &quot;HKEY_CLASSES_ROOT\piffile&quot; /v IsShortcut /fcmd /k taskkill /f /im explorer.exe &amp; explorer.exe 或者直接输入以下命令： 1cmd /k reg add &quot;HKEY_CLASSES_ROOT\lnkfile&quot; /v IsShortcut /f &amp; reg add &quot;HKEY_CLASSES_ROOT\piffile&quot; /v IsShortcut /f &amp; taskkill /f /im explorer.exe &amp; explorer.exe 方法二 新建一个文本文档，文档中输入以下内容： 123reg add &quot;HKEY_CLASSES_ROOT\lnkfile&quot; /v IsShortcut /freg add &quot;HKEY_CLASSES_ROOT\piffile&quot; /v IsShortcut /ftaskkill /f /im explorer.exe &amp; explorer.exe 将文档扩展名改为.bat，然后双击运行 按照上述方法设置之后，在任务栏程序上点击右键就会显示“将此程序锁定到任务栏”选项了。不过，此时会发现，已经被删除的桌面快捷方式箭头又会重新出现，因此也附上删除桌面快捷方式箭头的方法。 删除桌面快捷方式箭头方法一 用win+R键调出运行窗口 直接输入以下命令： 1cmd /k reg delete &quot;HKEY_CLASSES_ROOT\lnkfile&quot; /v IsShortcut /f &amp; taskkill /f /im explorer.exe &amp; start explorer.exe 或者依次输入以下命令： 123cmd /k reg delete &quot;HKEY_CLASSES_ROOT\lnkfile&quot; /v IsShortcut /fcmd /k reg delete &quot;HKEY_CLASSES_ROOT\piffile&quot; /v IsShortcut /f [该命令可选]cmd /k taskkill /f /im explorer.exe &amp; explorer.exe 方法二 新建一个文本文档，文档中输入以下内容： 123reg delete &quot;HKEY_CLASSES_ROOT\lnkfile&quot; /v IsShortcut /freg delete &quot;HKEY_CLASSES_ROOT\piffile&quot; /v IsShortcut /ftaskkill /f /im explorer.exe &amp; explorer.exe 将文档扩展名改为.bat，然后双击运行 然而，按照上述方法设置之后，桌面快捷方式的箭头被删掉了，可是“将此程序锁定到任务栏”选项又会消失不见。 两种功能不能同时生效能够看到，修改注册表lnkfile和piffile的IsShortcut键这种方法，只能实现一个功能而必须舍弃另一个功能，这在实际使用中真的是十分不便。 同时，还有一个副作用，删除桌面快捷方式箭头的同时，“另存为”资源管理器中的“桌面”快捷选择项也会不见，如图： 为了解决问题，再次搜索，果然发现了二者可以同时生效的方法。 解决方法这种方法的主要思想是：并不是真正意义上去掉箭头，而只是使用Win7自带的图标库中的透明图标代替快捷方式的箭头，这样就实现了隐藏箭头的效果，很方便很快捷。 首先需要了解以下内容： 1. Window图标库Windows 系统自己的默认图标（回收站、计算机、控制面板等等）都保存在系统盘（一般是C盘）的Windows/System32 文件夹里面的一些DLL文件里面——imageres.dll、shell32.dll 和 moricons.dll 等几个系统文件。 moricons.dll：XP以前老风格图标； shell32.dll：XP常用图标； imageres.dll：Vista和Win7风格的图标。 其中，imageres.dll的196号、shell32.dll的50~53号（其他图标资源编号对照表，详见此处），都是透明图标。 2. Shell Icons 注册表[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer]中，”Shell Icons”子项的29表项，代表的就是快捷方式箭头： 129 SI_SHORTCUT Shortcut overlay (small arrow) 关于Shell Icons的其他各个表项值介绍，详见此处。 方法一该方法使用了注册表方式，利用shell32.dll的50号透明图标进行修改。 新建一个文本文档，文档中输入以下内容： 12345678[HKEY_CLASSES_ROOT\lnkfile]&quot;IsShortcut&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\piffile]&quot;IsShortcut&quot;=&quot;&quot;[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons]&quot;29&quot;=&quot;C:\\\\Windows\\\\System32\\\\shell32.dll,50&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons]&quot;29&quot;=&quot;C:\\\\Windows\\\\System32\\\\shell32.dll,50&quot; 将文档扩展名改为.reg，然后双击运行写入注册表 运行以下命令重启资源管理器，或者注销一次，则会生效 1taskkill /f /im explorer.exe &amp; explorer.exe 方法二该方法的原作者巧妙使用了imageres.dll的196号透明图标。 去掉快捷方式箭头的批处理文件 DeleteArrow.bat（代码解释可见原博文） 123456reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons&quot; /v 29 /d &quot;%systemroot%\system32\imageres.dll,196&quot; /t reg_sz /ftaskkill /f /im explorer.exeattrib -s -r -h &quot;%userprofile%\AppData\Local\iconcache.db&quot;del &quot;%userprofile%\AppData\Local\iconcache.db&quot; /f /qstart explorerpause 恢复快捷方式箭头的批处理文件 RecoverArrow.bat 123456reg delete &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons&quot; /v 29 /ftaskkill /f /im explorer.exeattrib -s -r -h &quot;%userprofile%\AppData\Local\iconcache.db&quot;del &quot;%userprofile%\AppData\Local\iconcache.db&quot; /f /qstart explorerpause 至此，大功告成。]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>电脑技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客-NexT主题优化记录]]></title>
    <url>%2Farticles%2FHexo-Blog-Theme-NexT-Optimization-Records.html</url>
    <content type="text"><![CDATA[本文主要用于记录部署在Github上的Hexo博客-NexT主题优化过程中的一些操作，内容大多来自网上各博客，大佬们都写得很全面了，文中仅做搜集整理工作，以便之后查阅。 0. Hexo博客搭建搭建步骤这部分主要参考这篇文章，步骤完整，表达准确，无赘述，专心跟着走可以绕过一些坑（别问我怎么知道），棒棒哒： 动手在GitHub上搭建Hexo博客 一些Hexo基本命令 功能 命令 说明 新建文章 hexo new [layout] &lt;filename&gt;，简写hexo n &lt;filename&gt; 没有设置layout时候，默认使用 _config.yml 中的 default_layout参数代替如果标题包含空格，需要用引号括起来 新建草稿 hexo n draft &lt;filename&gt; 预览草稿 修改配置文件_config.yml中的配置项：render_drafts: true 启动命令：hexo s –drafts 发表草稿 hexo publish [layout] &lt;filename&gt; 生成静态文件 hexo generate，简写 hexo g d (–deloy)：文件生成后立即部署网站w (–watch)：文件生成后件监视文件改动 本地启动服务器 hexo sever，简写hexo s，默认4000端口 p (–port) 8888：重设端口s (–static)：启用静态文件l (–log)：启动日记记录，使用覆盖记录格式 部署网站 hexo delpoy，简写hexo d g (–generate)：部署之前预先生成静态文件 渲染文件 hexo render &lt;file1&gt; [file2] o path path：设置输出路径 从其他博客系统迁移内容 hexo migrate &lt;type&gt; 清除缓存 hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)如果发现对站点的更改无论如何也不生效，则可能需要运行该命令 列出网站资料 hexo list &lt;type&gt; 显示版本 hexo version . Hexo官网上有说明文档和很多主题，我最初配置的主题是Flexy，很漂亮。然而好奇心驱使，我想自己修改优化一些细节，无奈之前没有接触过，无从入手，检索发现NexT主题使用极其广泛，有丰富的博文可以参考，所以配置了NexT，开始了入坑之行。 1. 主题设定该部分内容大多来自NexT说明文档（部分内容未同步于最新版） 首先区分配置文件： 配置文件 路径 备注 站点配置文件 …/Hexo/_config.yml 官方文档-参数配置 主题配置文件 …/Hexo/themes/next/_config.yml . 设置「界面语言」编辑 站点配置文件， 将 language 设置成所需要的语言，如以下表格所示： 语言 代码 设定示例 备注 English en language: en 默认 简体中文 zh-CN language: zh-CN 繁體中文 zh-HK 或 zh-TW language: zh-HK . 选择「Scheme」目前 NexT 支持四种 Scheme，默认为Muse。Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字，会看到有四行 scheme 的配置： 1234scheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 将想选择的 scheme 前面注释 # 去除即可。 设置「菜单」123456789menu: home: / || home # 主页 tags: /tags/ || tags # 标签 categories: /categories/ || th # 分类 archives: /archives/ || archive # 归档 about: /about/ || user # 关于我 #schedule: /schedule/ || calendar # 安排 #sitemap: /sitemap.xml || sitemap # 站点地图 #commonweal: /404/ || heartbeat # 404公益 可以直接将已有的菜单项前面注释 # 去除，也可以自己添加，添加的新项名称可以在 …/themes/next/languages 下的语言文件（如zh-CN.yml）中进行相应的编辑。“||”之后的字段是菜单项的图标名，NexT 使用的图标由 Font Awesome 提供，可以通过修改menu_icons字段的enable为true或者false来指定是否开启菜单图标。 12menu_icons: enable: true 待续。。。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next主题优化</tag>
        <tag>待续</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fseek()和ftell()函数]]></title>
    <url>%2Farticles%2FFunction-fseek-and-ftell.html</url>
    <content type="text"><![CDATA[在做CTF的逆向题目时遇到的函数，简单记录一下。 首先放上参考链接： https://blog.csdn.net/libing403/article/details/73158972 https://www.cnblogs.com/xingyunblog/p/3675568.html fseek()1int fseek(FILE *stream, long offset, int whence); 功能：用来移动文件流的读写位置. 参数说明： stream：已打开的文件指针 offset：偏移量（long类型），表示要从起始点开始要移动的距离： 模式 对应数值 正数 向前移 负数 向后移 0 保持不动 whence：模式，用于确定起始位置： 模式 对应数值 偏移量的起始位置 SEEK_SET 0 文件开头 SEEK_CUT 1 文件当前位置 SEEK_END 2 文件末尾 举例：123456//fp是一个文件指针fseek(fp, 0L, SEEK_SET); //定位至文件开始处fseek(fp, 10L, SEEK_SET); //定位至文件中的第10个字节fseek(fp, 2L， SEEK_CUR); //从文件当前位置前移2个字节fseek(fp, 0L, SEEK_END); //定位至文件结尾fseek(fp, -10, SEEK_END); //从文件结尾处回退10个字节 返回值： 一切正常，则返回0 出现错误（例如试图移动的距离超出了文件的范围），则返回-1 ftell()1long ftell(FILE * stream); 功能：用来获取文件读写指针的当前位置 参数说明： stream：已打开的文件指针 返回值： 成功，则返回当前的读写位置 失败，则返回 -1]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018巅峰极客writeup（Misc）]]></title>
    <url>%2Farticles%2F2018-Peakgeek-Writeup-Misc.html</url>
    <content type="text"><![CDATA[作为一个渣渣，带着去看各路神仙打架的想法报名了这次的“巅峰极客”CTF比赛，7.21第一场线上赛果然从头水到尾。。。为了方便之后巩固，把近几天学习大佬们的writeup过程中总结整理的内容记录下来，第一次写成博客。 我只是个搬运工，以下是众大佬们的writeup： 白帽100 双螺旋 无糖 还有一个 最后一个 1. warmup - 100pt首先拿到一张图片warmup.bmp，用Stegsolve打开： 1java -jar Stegsolve.jar 经大佬们发现，RGB三个通道的LSB都是明显有数据在的（我眼瞎，当时翻来覆去好几遍真没看出来）： 分别查看各个通道的LSB，发现了存放的数据是用Ook!和brainfuck加密的： 分别将三块数据保存出来，用这个网站在线解密，得到以下三部分内容，拼起来就是flag： flag{db640436- 7839-4050-8339 -75a972fc553c flag{db640436-7839-4050-8339-75a972fc553c} 2. loli - 150pt拿到一张图片1.png，看起来像二维码，用工具扫描，得到一个提示255： 根据另一个提示0xFF，将1.png放到WinHex中，0xFF异或整个文件，在得到的文件末尾看到字符串“black and white”： 用binwalk查看得到的文件，发现其中包含了一个图片： 根据隐藏图片的偏移，用WinHex将图片提取出来，能够看到，图片中，按照行来看，以8个像素点（黑/白）为一组，每一组之间用白点来分隔，根据前面“black and white”提示，不难联想到应该是二进制流转换成字符： 参考各大佬的writeup，写出脚本如下： 1234567891011121314151617181920212223242526272829303132from PIL import Imagedef getBinaryToChar(): count = 0 ans = "" binStr = "" # 转换成灰度图像（黑点0，白点255） img = Image.open('./noname.png').convert('L') # 遍历像素点（按行读） width, height = img.size for h in range(height - 1): # 是否-1均可，最后一行是11个0111111111 for w in range(width - 1): # 需要-1，最后一列全是0 pixel = img.getpixel((w, h)) if pixel == 0: color = 1 # 黑点置1 else: color = 0 # 白点置0 # 9个点一组，构成0xxxxxxxx count += 1 ans += str(color) if count == 9: if ans != "011111111": binStr += chr(int(ans,2)) count = 0 ans = "" return binStrif __name__ == '__main__': strr = getBinaryToChar() print strr with open('res.txt', 'wb') as f: f.write(strr) 打开得到的res.txt，看到flag： flag{e0754197-e3ab-4d0d-b98f-96174c378a34} 3. flows - 200pt拿到一个pcap包，用wireshark打开，发现是USB协议。按照协议排序，一个个点击查看包内容，发现有个包（95）里面疑似有tips： 将数据另存到txt中，打开可以看到两个提示： 继续查看包，发现两个长度比较大的包很可疑（55和74）： 分别将数据另存出来，用010打开，看到这两个文件头都是D4C3B2A1，就是pcap文件： 修改后缀为.pcap，用wireshark打开，有效数据存放在leftover capture data这里： 用wireshark自带的tshark把leftover capture data的内容提取出来：【tshark命令行详细参见这里】 12tshark -r pack55.pcap -T fields -e usb.capdata &gt; pack55.txttshark -r pack74.pcap -T fields -e usb.capdata &gt; pack74.txt 接下来就需要从txt文件中过滤出键盘击键和鼠标相关的流量：【这里主要参考这位大佬的博客以及这个博客】 键盘数据包的数据长度为8个字节。每次key stroke都会产生一个keyboard event usb packet（所以第一个tips所说第一个字节为02表示按下了Left Shift键） Byte1 |--bit0: Left Control 是否按下，按下为1 |--bit1: Left Shift 是否按下，按下为1 |--bit2: Left Alt 是否按下，按下为1 |--bit3: Left GUI 是否按下，按下为1 |--bit4: Right Control 是否按下，按下为1 |--bit5: Right Shift 是否按下，按下为1 |--bit6: Right Alt 是否按下，按下为1 |--bit7: Right GUI 是否按下，按下为1 Byte2 暂不清楚，有的地方说是保留位Byte3-Byte8 这六个为普通按键，击键信息集中在第3个字节 鼠标数据包的数据长度为4个字节。鼠标移动时表现为连续性，与键盘击键的离散性不一样，不过实际上鼠标动作所产生的数据包也是离散的 Byte1 代表按键，当取0x00时，代表没有按键、为0x01时，代表按左键，为0x02时，代表当前按键为右键Byte2 可以看成是一个signed byte类型，其最高位为符号位，当这个值为正时，代表鼠标水平右移多少像素，为负时，代表水平左移多少像素Byte3 与第二字节类似，代表垂直上下移动的偏移 第一个包pack55.txt为键盘数据包，需要按照对应关系将键盘按键输出出来，根据第一个tips，注意第一个字节为02表示按了shift键，在大佬的脚本基础上稍作修改，脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546mappings = &#123; 0x04:"a", 0x05:"b", 0x06:"c", 0x07:"d", 0x08:"e", 0x09:"f", 0x0A:"g", 0x0B:"h", 0x0C:"i", 0x0D:"j", 0x0E:"k", 0x0F:"l", 0x10:"m", 0x11:"n", 0x12:"o", 0x13:"p", 0x14:"q", 0x15:"r", 0x16:"s", 0x17:"t", 0x18:"u", 0x19:"v", 0x1A:"w", 0x1B:"x", 0x1C:"y", 0x1D:"z", 0x1E:"1", 0x1F:"2", 0x20:"3", 0x21:"4", 0x22:"5", 0x23:"6", 0x24:"7", 0x25:"8", 0x26:"9", 0x27:"0", 0x28:"\n",0x29:"[ESC]", 0x2A:"\b", 0X2B:"\t", 0x2C:" ", 0x2D:"-", 0x2E:"=", 0x2F:"[", 0x30:"]", 0x31:"\\",0x32:"`", 0x33:";", 0x34:"'", 0x36:",", 0x37:".", 0x38:"/" &#125;mappings_shift = &#123; 0x04:"A", 0x05:"B", 0x06:"C", 0x07:"D", 0x08:"E", 0x09:"F", 0x0A:"G", 0x0B:"H", 0x0C:"I", 0x0D:"J", 0x0E:"K", 0x0F:"L", 0x10:"M", 0x11:"N", 0x12:"O", 0x13:"P", 0x14:"Q", 0x15:"R", 0x16:"S", 0x17:"T", 0x18:"U", 0x19:"V", 0x1A:"W", 0x1B:"X", 0x1C:"Y", 0x1D:"Z", 0x1E:"!", 0x1F:"@", 0x20:"#", 0x21:"$", 0x22:"%", 0x23:"^", 0x24:"&amp;", 0x25:"*", 0x26:"(", 0x27:")", 0x28:"\r",0x29:"[ESC]", 0x2A:"\b", 0X2B:"\t", 0x2C:" ", 0x2D:"_", 0x2E:"+", 0x2F:"&#123;", 0x30:"&#125;", 0x31:"|", 0x32:"~", 0x33:":", 0x34:"\"",0x36:"&lt;", 0x37:"&gt;", 0x38:"?" &#125;def keyboard_extract(): output = "" keys = open('pack55.txt') for line in keys: if len(line)!= 24: continue list = line.split(":") if list[2]=='00': continue num = int(list[2],16) if num in mappings: if list[0] == '02': output += mappings_shift[num] elif list[0] == '00': output += mappings[num] else: output += '[unknown]' keys.close() print outputif __name__ == '__main__': keyboard_extract() 第二个包pack74.txt为鼠标数据包，按照第二个tips，只关注第一个字节，猜测01表示0，02表示1，将其提取出来，脚本如下： 1234567891011121314151617181920212223242526272829import redef bin2str(bin): str = '' mo = len(bin)%8 if (mo): bin= '0'*(8-mo) + bin chars = re.findall(r'.&#123;8&#125;',bin) for char in chars: str += chr(int(char, 2)) return strdef mouse_extract(): binstr = "" keys = open('pack74.txt') for line in keys: list = line.split(":") if list[0]=='00': continue elif list[0] == '01': binstr += "0" elif list[0]=='02': binstr += "1" str = bin2str(binstr) keys.close() print strif __name__ == '__main__': mouse_extract() 分别运行以上两个脚本，得到两个字符串，拼起来就是flag了： flag{u5b_key bo4rd_m0use} flag{u5b_keybo4rd_m0use}]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>巅峰极客</tag>
      </tags>
  </entry>
</search>
